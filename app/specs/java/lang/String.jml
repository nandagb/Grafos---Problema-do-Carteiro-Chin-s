// @(#)$Id: String.spec 2412 2007-04-19 16:53:31Z mikolas $

// Copyright (C) 2000 Iowa State University

// This file is part of JML

// JML is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.

// JML is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JML; see the file COPYING.  If not, write to
// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

package java.lang;

import java.io.UnsupportedEncodingException;
import java.util.Locale;
import java.util.regex.Pattern;
import java.util.Comparator;
import java.nio.charset.Charset;

/** JML's specification of java.lang.String.
 * @version $Revision: 2412 $
 * @author Gary T. Leavens
 * @author David R. Cok
 * @author Yoosik Cheon
 * @author Clyde Ruby
 * @author Patrice Chalin
 * @author Joseph R. Kiniry
 * @author Mikolas Janota
 */
//+OPENJML@ immutable 
//@ non_null_by_default
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence
{
    // NOTE: The value of the String is modeled by the charArray in CharSequence

    public static final Comparator<String> CASE_INSENSITIVE_ORDER;

    //-RAC@ public normal_behavior
    //-RAC@   ensures true;
    //-RAC@ static_initializer
    
    //---------------------------------------------------------------------
    // Constructors (and their helpers)
    //---------------------------------------------------------------------

    //@ initially !isInterned(this);

    /*-RAC@  public normal_behavior
      @      ensures initialCharSequence();
      @      ensures charArray.length == 0;
      @      ensures String.equals(this,"");
      @*/
    public /*@ pure @*/ String();

    //@  public normal_behavior
    //@   requires original != null;
    //-RAC@   ensures initialCharSequence();
    //-RAC@   ensures equals(this,original);
    //@
    //@ also public exceptional_behavior
    //@   requires original == null;
    //@   assignable \nothing;
    //@   signals_only NullPointerException;
    public /*@ pure @*/ String(String original) throws NullPointerException;

    /*@  public normal_behavior
      @   requires value != null;
      @   ensures this.length() == value.length;
      @   //-RAC@ ensures this.charArray.length == value.length;
      @   //-RAC@ ensures initialCharSequence();
      @   //-RAC@ ensures CharSequence.equal(charArray,value);
      @   ensures (\forall int i; 0<=i && i<value.length; this.charAt(i) == value[i]);
      @
      @ also public exceptional_behavior
      @   requires value == null;
      @   assignable \nothing;
      @   signals_only NullPointerException;
      @*/
    public /*@ pure @*/ String(char[] value);

    /*@
      @  public exceptional_behavior
      @   requires value == null
      @             || (offset < 0
      @                 || (offset + count) > value.length
      @                 || count < 0);
      @   assignable \nothing;
      @   signals_only StringIndexOutOfBoundsException, NullPointerException;
      @   signals (NullPointerException) value == null;
      @   signals (StringIndexOutOfBoundsException) offset < 0 || count < 0 ||
                 (value != null && (offset+count)>value.length);
      @
      @ also
      @  public normal_behavior
      @   requires value != null
      @             && 0 <= offset 
      @             && (offset + count) <= value.length
      @             && 0 <= count;
      @   //ensures charArray != null;
      @   //-RAC@ ensures CharSequence.equal(charArray,0,value,offset,count);
      @   //-RAC@ ensures charArray.length == count;
      @   //-RAC@ ensures (offset == 0 && count == value.length) ==> CharSequence.equal(charArray,value);
      @*/
    public /*@ pure @*/ String(char[] value, int offset, int count)
        throws StringIndexOutOfBoundsException, NullPointerException;

    /*@  public normal_behavior
      @   ensures \result == (char) (((hibyte & 0xff) << 8) | (ascii & 0xff));
    public pure model char byteToChar(int hibyte, byte ascii); @*/

    /** @deprecated as of 1.1 */
    /*@  public normal_behavior
      @   requires ascii != null
      @             && 0 <= offset 
      @             && (offset + count) < ascii.length
      @             && 0 <= count;
      @   //-RAC@ ensures charArray.length == count;
      @   //-RAC@ ensures (\forall int i; 0 <= i && i < count;
      @   //-RAC@             (charArray[i]
      @   //-RAC@             == byteToChar(hibyte, ascii[i+offset])));
      @ also
      @  public exceptional_behavior
      @   requires ascii != null
      @             && (offset < 0
      @                 || (offset + count) < ascii.length
      @                 || count < 0);
      @   signals_only StringIndexOutOfBoundsException;
      @
      @ also public exceptional_behavior
      @   requires ascii == null;
      @   assignable \nothing;
      @   signals_only NullPointerException;
      @*/
    @Deprecated public /*@ pure @*/ String(byte[] ascii, int hibyte,
                  int offset, int count)
        throws StringIndexOutOfBoundsException;
  
    /** @deprecated as of 1.1 */
    /*@  public normal_behavior
      @   requires ascii != null;
      @   //-RAC@ ensures charArray.length == ascii.length;
      @   //-RAC@ ensures (\forall int i;  0 <= i && i < ascii.length;
      @   //-RAC@           charArray[i] == byteToChar(hibyte, ascii[i]));
      @
      @ also public exceptional_behavior
      @   requires ascii == null;
      @   assignable \nothing;
      @   signals_only NullPointerException;
      @*/
    @Deprecated public /*@ pure @*/ String(byte[] ascii, int hibyte);

    // Define the following to be true (e.g. with an axiom) to declare
    // a given encoding as supported.  FIXME - define this in terms of
    // functionality in java.nio.charset.Charset.
    //@ public static pure model boolean supportedEncoding(String charsetName);
    //@ public static pure model boolean supportedEncoding(Charset charsetName);

    /*+ESC@ public normal_behavior
      @  requires bytes != null && charsetName != null
      @             && 0 <= offset 
      @             && (offset + length) <= bytes.length
      @             && 0 <= length;
      @     requires supportedEncoding(charsetName);
      @     ensures charArray.length <= length;
      @     ensures 
      @            (\forall int i; 0 <= i && i < length;
      @                  (* charArray[i] == 
      @                     char at position i of the conversion of subarray
      @                     of bytes using the encoding charsetName *));
      @
      @ also public exceptional_behavior
      @   requires bytes == null || charsetName == null ||
                   !supportedEncoding(charsetName) ||
                   (offset < 0 || length < 0 || offset+length>bytes.length);
      @   assignable \nothing;
      @   signals_only NullPointerException, StringIndexOutOfBoundsException,
                                  UnsupportedEncodingException;
      @   signals (StringIndexOutOfBoundsException e) 
                           offset<0 || length<0 || (offset+length)>bytes.length;
      @   signals (NullPointerException) bytes==null || charsetName == null;
      @   signals (UnsupportedEncodingException) charsetName != null &&
                         !supportedEncoding(charsetName);
      @*/
    public /*@ pure @*/ String(byte[] bytes,
                                 int offset, int length,
                                 String charsetName)
        throws UnsupportedEncodingException;

    /*+ESC@ public normal_behavior
      @  requires bytes != null && charsetName != null
      @             && 0 <= offset 
      @             && (offset + length) <= bytes.length
      @             && 0 <= length;
      @     requires supportedEncoding(charsetName);
      @     ensures charArray.length <= length;
      @     ensures 
      @            (\forall int i; 0 <= i && i < length;
      @                  (* charArray[i] == 
      @                     char at position i of the conversion of subarray
      @                     of bytes using the encoding charsetName *));
      @
      @ also public exceptional_behavior
      @   requires bytes == null || charsetName == null ||
                   !supportedEncoding(charsetName) ||
                   (offset < 0 || length < 0 || offset+length>bytes.length);
      @   assignable \nothing;
      @   signals_only NullPointerException, StringIndexOutOfBoundsException,
                                  UnsupportedEncodingException;
      @   signals (StringIndexOutOfBoundsException e) 
                           offset<0 || length<0 || (offset+length)>bytes.length;
      @   signals (NullPointerException) bytes==null || charsetName == null;
      @   //signals (UnsupportedEncodingException) charsetName != null &&
          //                 !supportedEncoding(charsetName);
      @*/
    public /*@ pure @*/ String(byte[] bytes,
                                 int offset, int length,
                                 Charset charsetName)
        throws UnsupportedEncodingException;
    
    /*+ESC@ public normal_behavior
      @   requires bytes != null && charsetName != null;
      @ also public exceptional_behavior
      @   requires bytes == null || charsetName == null;
      @   signals (NullPointerException) bytes==null || charsetName == null;
      @*/
    public /*@ pure @*/ String(byte[] bytes, Charset charsetName);
    
    /*@
      @  public exceptional_behavior
      @   requires bytes == null || charsetName == null
                   || !supportedEncoding(charsetName);
      @   signals_only NullPointerException, UnsupportedEncodingException;
      @   signals (NullPointerException) bytes==null || charsetName == null;
      @   signals (UnsupportedEncodingException) charsetName != null &&
      @                                     !supportedEncoding(charsetName);
      @
      @
      @ also
      @ public behavior
      @   requires bytes != null && charsetName != null;
      @   requires supportedEncoding(charsetName);
      @   //-RAC@ ensures charArray.length <= bytes.length;
      @   // ensures charArray is the translation of bytes
      @*/
    public /*@ pure @*/ String(byte[] bytes, String charsetName)
        throws UnsupportedEncodingException;

    /*@  public behavior
      @   requires bytes != null
      @             && 0 <= offset 
      @             && (offset + length) <= bytes.length
      @             && 0 <= length;
      @   //-RAC@ ensures charArray.length <= length;
      @   // ensures charArray is the translation of bytes with the 
      @   // default file encoding System.getProperty("file.encoding")
      @
      @ also public exceptional_behavior
      @   requires bytes == null;
      @   assignable \nothing;
      @   signals_only NullPointerException;
      @
      @ also public exceptional_behavior
      @   requires bytes != null && 
                 (offset < 0 || length < 0 || offset+length > bytes.length);
      @   assignable \nothing;
      @   signals_only StringIndexOutOfBoundsException;
      @
      @*/
    public /*@ pure @*/ String(byte[] bytes, int offset, int length);

    /*@  public normal_behavior
      @   requires bytes != null;
      @   //-RAC@ ensures charArray.length <= bytes.length;
      @   // ensures charArray is the translation of bytes with the 
      @   // default file encoding System.getProperty("file.encoding")
      @
      @ also public exceptional_behavior
      @   requires bytes == null;
      @   assignable \nothing;
      @   signals_only NullPointerException;
      @*/
    public /*@ pure @*/ String(byte[] bytes);

    /*@ public normal_behavior
      @   requires buffer != null;
      @   ensures equals(this,buffer.accumulatedString);
      @
      @ also public exceptional_behavior
      @   requires buffer == null;
      @   assignable \nothing;
      @   signals_only NullPointerException;
      @*/
    public /*@ pure @*/ String (StringBuffer buffer);


    //---------------------------------------------------------------------
    // Methods
    //---------------------------------------------------------------------

    /*@ public normal_behavior
      @   //-RAC@ ensures \result == s.charArray.length;
      @
      @ //@ heap_free
      @ public static model pure helper int length(String s);
      @*/
    // inherits specs from CharSequence - \result == charArray.length
    public /*@ pure helper heap_free @*/ int length();
    
    /*@ also public normal_behavior
      @   //-RAC@ ensures \result == (this.charArray.length == 0);
      @*/
    @Override
    public /*@ pure @*/ boolean isEmpty();

    /*@ // Inherited from CharSequence:
      @ //also public normal_behavior
      @ //  requires 0 <= index && index < charArray.length;
      @ //  ensures \result == charArray[index];
      @ also public exceptional_behavior
      @   requires index < 0 || index >= length();
      @   signals_only StringIndexOutOfBoundsException;
      @*/
    public /*@ pure @*/ char charAt(int index)
        throws StringIndexOutOfBoundsException;

    /*@  public normal_behavior
      @   requires srcBegin >= 0
      @             && srcEnd <= length()
      @             && srcBegin <= srcEnd
      @             && dst != null
      @             && dst.length >= dstBegin + (srcEnd - srcBegin);
      @   modifies dst[dstBegin .. dstBegin+srcEnd-srcBegin-1];
      @   //-RAC@ ensures CharSequence.equal(charArray,srcBegin,dst,dstBegin,srcEnd-srcBegin);
      @ also
      @  public exceptional_behavior
      @   requires (srcBegin < 0
      @              || srcEnd > length()
      @              || srcBegin > srcEnd)
      @             && dst != null
      @             && dst.length >= dstBegin + (srcEnd - srcBegin);
      @   modifies \nothing;
      @   signals_only StringIndexOutOfBoundsException;
      @ also
      @  public exceptional_behavior
      @   requires dst == null;
      @   modifies \nothing;
      @   signals_only NullPointerException;
      @*/
    public void getChars(int srcBegin, int srcEnd,
                                        char[] dst, int dstBegin)
      throws StringIndexOutOfBoundsException;

    /** @deprecated as of 1.1, use getBytes() */
    /*@  public normal_behavior
      @   requires srcBegin >= 0
      @             && srcEnd <= length()
      @             && srcBegin <= srcEnd
      @             && dst != null
      @             && dst.length >= dstBegin + (srcEnd - srcBegin) + 1;
      @   modifies dst[dstBegin .. dstBegin+srcEnd-srcBegin-1];
      @   ensures (\forall int i; srcBegin <= i && i < srcEnd;
      @                            dst[(int)(dstBegin + i - srcBegin)]
      @                            == (byte) (charAt(i) & 0xff));
      @ also
      @  public exceptional_behavior
      @   requires (srcBegin <= 0
      @              || srcEnd > length()
      @              || srcBegin > srcEnd)
      @             && dst != null
      @             && dst.length >= dstBegin + (srcEnd - srcBegin) + 1;
      @   modifies \nothing;
      @   signals (StringIndexOutOfBoundsException);
      @ also
      @  public exceptional_behavior
      @   requires dst == null;
      @   modifies \nothing;
      @   signals_only NullPointerException;
      @*/
    @Deprecated public void getBytes(int srcBegin, int srcEnd,
                                        byte[] dst, int dstBegin)
      throws StringIndexOutOfBoundsException;

    /*@  public normal_behavior
      @   ensures \result == (a==b || ((a.length == b.length)
      @                       && (\forall int i; 0 <= i && i < a.length;
                                                 a[i] == b[i])));
    public static pure model boolean byteArraysEqual(byte[] a, byte[] b);   @*/

    /*@  public normal_behavior
      @   requires (* charsetName is the name of a supporting encoding *);
      @   ensures \fresh(\result);
      @   ensures (\forall int i; 0 <= i && i < \result.length;
      @                    (* \result[i] is the byte at position i of the 
      @                       conversion of this string's chars using charsetName *));
      @ also
      @  public exceptional_behavior
      @   requires !(* (charsetName is the name of a supporting encoding) *);
      @   signals_only UnsupportedEncodingException;
      @*/
    public /*@ pure @*/ /*@ non_null @*/ byte[] getBytes(String charsetName)
      throws UnsupportedEncodingException;

    /*@  public normal_behavior
      @   requires  (* charset is a supporting encoding *);
      @   ensures \fresh(\result);
      @   ensures (\forall int i; 0 <= i && i < \result.length;
      @                    (* \result[i] is the byte at position i of the 
      @                       conversion of this string's chars using charset *));
      @ also
      @  public exceptional_behavior
      @   requires !(* (charset is a supporting encoding) *);
      @   signals_only UnsupportedEncodingException;
      @*/
    public /*@ pure @*/ /*@ non_null @*/ byte[] getBytes(Charset charset)
      throws UnsupportedEncodingException;

    /*@  public normal_behavior
      @  ensures \fresh(\result)
      @           && byteArraysEqual(\result, 
      @                       getBytes(System.getProperty("file.encoding")));
      @*/
    public /*@ pure @*/ /*@ non_null @*/ byte[] getBytes();

    /*@ public normal_behavior
      @   requires s1 != null & s2 != null;
      @   //-RAC@ requires s1.charArray != null & s2.charArray != null; // OPENJML: TODO Needs the invariant that charArray is not null
      @   //-RAC@ ensures \result == CharSequence.equal(s1.charArray,s2.charArray);
      @ also public normal_behavior
      @   requires s1 == s2;
      @   ensures \result;
      @ also public normal_behavior
      @   requires s1 == null || s2 == null ||
                     (isInterned(s1) && isInterned(s2));
      @   ensures \result <==> (s1 == s2);
      @
      @ pure heap_free
      @ public static model helper boolean equals(nullable String s1, nullable String s2);
      @*/

    //-RAC@ axiom (\forall String s,ss; s != null && ss != null; equals(s,ss) ==> s.length() == ss.length());

    // @ axiom (\forall String s,ss; equals(s,ss) ==> equals(ss,s));  // FIXME - causes matching loop?

    //-RAC@ axiom (\forall String s1,s2,s3; equals(s1,s2) ==> (equals(s1,s3) <==> equals(s2,s3)));

    //@ also public normal_behavior
    //@   requires anObject != null && (anObject instanceof String);
    //-RAC@   ensures \result == equals(this,(String)anObject); // FIXME - causes many straightforward proofs to be incomplete
    //@ also public normal_behavior
    //@   requires !(anObject instanceof String);
    //@   ensures !\result;
    public /*@ pure @*/ boolean equals(/*@ nullable */ Object anObject);

    //@ public normal_behavior
    //@   requires sb != null;
    //-RAC@   ensures \result <==> String.equals(this,sb.accumulatedString);
    //@
    //@ also public exceptional_behavior
    //@   requires sb == null;
    //@   signals_only NullPointerException;
    public /*@ pure @*/ boolean contentEquals(StringBuffer sb);

    /*@  public normal_behavior
      @    ensures \result <==> (c1 == c2)
      @                        || (Character.toUpperCase(c1) 
      @                            == Character.toUpperCase(c2))
      @                        || (Character.toLowerCase(c1) 
      @                            == Character.toLowerCase(c2));
      public static pure model
          boolean charEqualsIgnoreCase(char c1, char c2); @*/

    /*@  public normal_behavior
      @    ensures \result <==> 
      @                         (Character.toLowerCase(c1) 
      @                            < Character.toLowerCase(c2));
      public static pure model
          boolean charLessIgnoreCase(char c1, char c2); @*/

    // FIXME - the first case is too complicated for ESC
    /*@  public normal_behavior
      @   requires anotherString != null;
//      @   ensures equals(this,anotherString) ==> \result;
//      @   ensures \result <==> (length() == anotherString.length())
//      @                        && (\forall int i;
//      @                             0 <= i && i < this.length();
//      @                              charEqualsIgnoreCase(
//      @                                   charAt(i),
//      @                                   anotherString.charAt(i)));
      @ also
      @ public normal_behavior
      @   requires anotherString == null;
      @   ensures !\result;
      @ also public normal_behavior
      @   requires anotherString == this;
      @   ensures \result;
      @*/
    //@ pure heap_free
    public boolean equalsIgnoreCase(String anotherString);

    // FIXME - overly complicated for esc?
    /*-RAC@
      @ public normal_behavior
      @   requires s1 != null && s2 != null;
      @   {|
      @     requires s2.length == 0 && s1.length == 0;
      @     ensures !\result;
      @   also
      @     requires s1.length == 0 && s2.length != 0;
      @     ensures \result;
      @   also
      @     requires s1.length != 0 && s2.length == 0;
      @     ensures !\result;
      @   also
      @     requires s1.length > 0 && s2.length > 0 && s1[0] != s2[0];
      @     ensures \result == (s1[0] < s2[0]);
      @   also
      @     ensures \result == (
      @               (\exists int i; 0 <= i && i < s1.length && i < s2.length;
      @                        s1[i] < s2[i] && CharSequence.equal(s1,0,s2,0,i))
      @               || 
      @                 (s1.length < s2.length && CharSequence.equal(s1,0,s2,0,s1.length))
      @               );
      @   |}
      @
    public static pure model boolean lessThan(char[] s1,
                                              char[] s2);  
      @*/

    /*-RAC@
      @  public normal_behavior
      @   requires s1 != null && s2 != null;
      @   {|
      @     requires s2.length == 0 && s1.length == 0;
      @     ensures !\result;
      @   also
      @     requires s1.length == 0 && s2.length != 0;
      @     ensures \result;
      @   also
      @     requires s1.length != 0 && s2.length == 0;
      @     ensures !\result;
      @   also
      @     requires s1.length > 0 && s2.length > 0 
                                 && !charEqualsIgnoreCase(s1[0],s2[0]);
      @     ensures \result == charLessIgnoreCase(s1[0],s2[0]);
      @   also
      @     ensures \result == (
      @               (\exists int i; 0 <= i && i < s1.length && i < s2.length;
      @                        charLessIgnoreCase(s1[i],s2[i]) && 
                               (\forall int j; 0<=j && j<i ;
                                       charEqualsIgnoreCase(s1[j],s2[j])))
      @               || 
      @                 (s1.length < s2.length && 
                               (\forall int j; 0<=j && j<s1.length ;
                                       charEqualsIgnoreCase(s1[j],s2[j])))
      @               );
      @   |}
    public static pure model boolean lessThanIgnoreCase(char[] s1,
                                              char[] s2);  @*/

    /*-RAC@ axiom (\forall char[] s1, s2; s1 != null && s2 != null;
                   !CharSequence.equal(s1,s2) ==> (lessThan(s1,s2) <=!=> lessThan(s2,s1)));
     */

    /*@ also public normal_behavior
      @   requires anotherString != null;
      @   //-RAC@ {|
      @       //-RAC@ requires  CharSequence.equal(charArray,anotherString.charArray);
      @       //-RAC@ ensures \result == 0;
      @  //-RAC@   also
      @  //-RAC@     requires  lessThan(charArray,anotherString.charArray);
      @  //-RAC@     ensures \result < 0;
      @  //-RAC@   also
      @  //-RAC@     requires  lessThan(anotherString.charArray,charArray);
      @  //-RAC@     ensures \result > 0;
      @   //-RAC@ |}
      @*/
    public /*@ pure @*/ int compareTo(String anotherString);


    /*@  public normal_behavior
      @   requires str != null;
      @   {|
      @       requires equalsIgnoreCase(str);
      @       ensures \result == 0;
      @   //-RAC@  also
      @   //-RAC@    requires lessThanIgnoreCase(charArray, str.charArray);
      @   //-RAC@    ensures \result < 0;
      @   //-RAC@  also
      @   //-RAC@    requires lessThanIgnoreCase(str.charArray, charArray);
      @   //-RAC@    ensures \result > 0;
      @   |}
      @*/
    public /*@ pure @*/ int compareToIgnoreCase(String str);

    /*@  public normal_behavior
      @   requires other != null;
      @   ensures \result == regionMatches(false,toffset,other,ooffset,len);
      @*/
    public /*@ pure @*/ boolean regionMatches(int toffset, String other, 
                                 int ooffset, int len);

    /*@ public normal_behavior
      @  requires other != null;
      @  {|
      @   requires (0 <= toffset && (toffset + len) <= length())
      @             && (0 <= ooffset && (ooffset + len) <= other.length())
      @             && ignoreCase;
      @   ensures \result == substring(toffset, (int)(toffset + len)).equalsIgnoreCase(
      @                        other.substring(ooffset, (int)(ooffset + len)));
      @  also
      @   requires (0 <= toffset && (toffset + len) <= length())
      @             && (0 <= ooffset && (ooffset + len) <= other.length())
      @             && !ignoreCase;
      @   ensures \result == equals(
                            substring(toffset, (int)(toffset + len)),
      @                     other.substring(ooffset, (int)(ooffset + len)));
      @  also
      @   requires (toffset < 0 || (toffset + len) > length())
      @             || (toffset < 0 || (ooffset + len) > other.length());
      @   ensures !\result;
      @  |}
      @*/
    public /*@ pure @*/ boolean regionMatches(boolean ignoreCase,
                                                int toffset, String other, 
                                                int ooffset, int len);

    /*@  public normal_behavior
      @   requires prefix != null && 0 <= toffset && toffset + prefix.length() <= length();
      @   //-RAC@ ensures \result ==  CharSequence.equal(charArray,toffset,prefix.charArray,0,prefix.charArray.length);
      @  also
      @   requires prefix != null && toffset + prefix.length() >= length();
      @   ensures !\result;
      @*/
    public /*@ pure @*/ boolean startsWith(String prefix, int toffset);

    /*@  public normal_behavior
      @   requires prefix != null;
      @   ensures \result == startsWith(prefix, 0);
      @*/
    public /*@ pure @*/ boolean startsWith(String prefix);

    /*@  public normal_behavior
      @   requires suffix != null && suffix.length() <= length();
      @   ensures \result == equals(
                                substring((int)(length() - suffix.length())),
      @                         suffix);
      @  also
      @   requires suffix != null && suffix.length() > length();
      @   ensures !\result;
      @*/
    public /*@ pure @*/ boolean endsWith(String suffix);

    // specification is inherited, this method does have side effects!
    public int hashCode();

    /*@  public normal_behavior
      @   ensures \result == indexOf(ch, 0);
      @*/
    public /*@ pure @*/ int indexOf(int ch);

    // behavior is not described if fromIndex >= length() but this
    // specification reflects the implementation
    /*@  public normal_behavior
      @   requires fromIndex >= length();
      @   ensures \result == -1;
      @  //also
      @  // requires fromIndex < 0;
      @  // ensures \result == indexOf(ch, 0); // Note - can't use recursive
      @  also
      @   requires fromIndex < length();
      @   {|
      @     requires charAt((fromIndex < 0 ? 0 : fromIndex)) == ch;
      @     ensures \result == (fromIndex < 0 ? 0 : fromIndex);
      @   also
      @     //-RAC@ ensures \result == -1 <==> (\forall int i; (fromIndex < 0 ? 0 : fromIndex) <= i < charArray.length; charArray[i] != ch);
      @     //-RAC@ ensures \result != -1 <==> ((fromIndex < 0 ? 0 : fromIndex) <= \result < charArray.length);
      @     //-RAC@ ensures \result != -1  ==> (
      @     //-RAC@            charArray[\result] == ch &&
      @     //-RAC@            (\forall int i; (fromIndex < 0 ? 0 : fromIndex) <= i < \result;
      @     //-RAC@                 charArray[i] != ch));
      @   |}
      @*/
    public /*@ pure @*/ int indexOf(int ch, int fromIndex);

    /*@  public normal_behavior
      @   ensures \result == lastIndexOf(ch, (int)(length() - 1));
      @*/
    public /*@ pure @*/ int lastIndexOf(int ch);

    // behavior is not described if fromIndex >= length() but this
    // specification reflects the implementation
    /*@ public normal_behavior
      @ {|
      @   requires fromIndex >= length();
      @   ensures \result == lastIndexOf(ch, (int)(length() - 1));
      @ also
      @   requires fromIndex < 0;
      @   ensures \result == -1;
      @ also
      @   requires 0 <= fromIndex && fromIndex < length();
      @   {|
      @     requires charAt(fromIndex) == ch;
      @     ensures \result == fromIndex;
      @   //also
      @   //  requires charAt(fromIndex) != ch;
      @   //  ensures \result == lastIndexOf(ch, (int)(fromIndex - 1)); // FIXME - no recursive use
      @   also
      @     //-RAC@ ensures \result == -1 <==> (\forall int i; 0 <= i <= fromIndex; charArray[i] != ch);
      @     ensures \result != -1 <==> (0 <= \result < fromIndex);
      @     //-RAC@ ensures \result != -1 <==> (
      @     //-RAC@            charArray[\result] == ch &&
      @     //-RAC@            (\forall int i; \result < i <= fromIndex; charArray[i] != ch));
      @   |}
      @ |}
      @*/
    public /*@ pure @*/ int lastIndexOf(int ch, int fromIndex);

    /*@ public normal_behavior
      @  requires str != null;
      @  ensures \result == indexOf(str, 0);
      @*/
    public /*@ pure @*/ int indexOf(String str);

    // behavior is not described if fromIndex >= length() but this
    // specification reflects the implementation
    /*@  public normal_behavior
      @   requires str != null;
      @   {|
      @     requires fromIndex >= length();
      @     ensures \result == -1;
      @   also
      @     requires fromIndex < 0;
      @     ensures \result == indexOf(str, 0);
      @   also
      @     requires 0 <= fromIndex && fromIndex < length();
      @     //-RAC@ ensures \result == -1 <==>
      @     //-RAC@           (\forall int i; 
      @     //-RAC@                  fromIndex <= i &&  i + str.length() < length();
      @     //-RAC@                  ! CharSequence.equal(charArray,i,str.charArray,0,str.length()));
      @     ensures \result != -1 <==> 
      @            (fromIndex <= \result && \result + str.length() <= length());
      @     //-RAC@ ensures \result != -1 <==>
      @     //-RAC@          (CharSequence.equal(charArray,\result,str.charArray,0,str.length()) &&
      @     //-RAC@           (\forall int i; 
      @     //-RAC@                  fromIndex <= i &&  i + str.length() < length();
      @     //-RAC@                  !CharSequence.equal(charArray,i,str.charArray,0,str.length())));
      @   |}
      @*/
    public /*@ pure @*/ int indexOf(String str, int fromIndex);

//    // a package-visible method - not specified
//    static /*@ pure @*/
//        int indexOf(char[] source, int sourceOffset, int sourceCount,
//                    char[] target, int targetOffset, int targetCount,
//                    int fromIndex);
      
    /*@  public normal_behavior
      @   requires str != null;
      @   ensures \result == lastIndexOf(str, (int)(length() - 1));
      @*/
    public /*@ pure @*/ int lastIndexOf(String str);

    // behavior is not described if fromIndex >= length() but this
    // specification reflects the implementation
    /*@  public normal_behavior
      @   requires str != null;
      @   {|
      @     requires length() <= fromIndex;
      @     ensures \result == lastIndexOf(str, (int)(length() - 1));
      @   also
      @     requires fromIndex < 0;
      @     ensures \result == -1;
      @   also
      @     requires 0 <= fromIndex < length();
      @     //-RAC@ ensures \result == -1 <==>
      @     //-RAC@           (\forall int i; 
      @     //-RAC@                  0 <= i &&  i <= fromIndex;
      @     //-RAC@                  ! CharSequence.equal(charArray,i,str.charArray,0,str.length()));
      @     ensures \result != -1 <==> (0 <= \result && \result <= fromIndex);
      @     //-RAC@ ensures \result != -1 <==>
      @     //-RAC@          (CharSequence.equal(charArray,\result,str.charArray,0,str.length()) &&
      @     //-RAC@           (\forall int i; 
      @     //-RAC@                  0 <= i &&  i <= fromIndex;
      @     //-RAC@                  !CharSequence.equal(charArray,i,str.charArray,0,str.length())));
      @   |}
      @*/
    public /*@ pure @*/ int lastIndexOf(String str, int fromIndex);
      
//    // a package-visible method not specified
//    static /*@ pure @*/
//        int lastIndexOf(char[] source, int sourceOffset, int sourceCount,
//                        char[] target, int targetOffset, int targetCount,
//                        int fromIndex);


    /*@  public normal_behavior
      @   requires 0 <= beginIndex <= length();
      @   //-RAC@ ensures \result.length() == this.length() - beginIndex
      @   //-RAC@      && CharSequence.equal(\result.charArray,0,charArray,beginIndex,
          //-RAC@                                           length()-beginIndex);
      @   ensures beginIndex == 0 ==> equals(this,\result);
      @ also
      @  public exceptional_behavior
      @   requires beginIndex < 0 || beginIndex > length();
      @   signals_only StringIndexOutOfBoundsException;
      @*/
    public /*@ pure @*/ /*@ non_null @*/ String substring(int beginIndex)
      throws StringIndexOutOfBoundsException;

    /*@  public normal_behavior
      @   requires 0 <= beginIndex <= endIndex <= length();
      @   //-RAC@ ensures \result.length() == endIndex - beginIndex
      @   //-RAC@      && CharSequence.equal(\result.charArray,0,charArray,beginIndex,
          //-RAC@                                           endIndex-beginIndex);
      @   ensures beginIndex == 0 && endIndex == length() ==>
                                        equals(this,\result);
      @ also
      @  public exceptional_behavior
      @   requires 0 > beginIndex
      @             || beginIndex > endIndex
      @             || (endIndex > length());
      @   signals_only StringIndexOutOfBoundsException;
      @*/
    public /*@ pure @*/ /*@ non_null @*/ String substring(int beginIndex,
                                                            int endIndex)
      throws StringIndexOutOfBoundsException;

    /*@ 
      @   // inherits normal behavior
      @ also
      @  public exceptional_behavior
      @   requires 0 > beginIndex
      @             || beginIndex > endIndex
      @             || (endIndex > length());
      @   signals_only StringIndexOutOfBoundsException;
      @*/
    public /*@ pure @*/ CharSequence subSequence(int beginIndex,
                                                   int endIndex);


    //@ public normal_behavior
    //@   requires s1 != null && s2 != null;
    //@   requires s1.length() + s2.length() <= Integer.MAX_VALUE;
    //@   //-RAC@ ensures \result.charArray != null; // FIXME - should be implict because of invariants?
    //@   ensures \result.length() == s1.length() + s2.length();
    //@   //-RAC@ ensures java.util.Arrays.equalArrays(\result.charArray,0,s1.charArray,0,s1.length());
    //@   //-RAC@ ensures java.util.Arrays.equalArrays(\result.charArray,s1.length(),s2.charArray,0,s2.length());
    //@ //-RAC@ also public normal_behavior
    //@ //-RAC@   requires !(s1 != null && s2 != null && s1.charArray.length + s2.charArray.length <= Integer.MAX_VALUE);
    //@ //-RAC@   ensures \result.charArray != null; // FIXME - should be implict because of invariants?
    //@ public model static pure non_null String concat(nullable String s1, nullable String s2);

    /** This is the method version of the infix + operation */
    //@ public normal_behavior
    //@     requires str == null; 
    //-RAC@      ensures \result.charArray != null; // FIXME - should be implict because of invariants?
    //@     ensures \result.length() == length() + 4;
    //@ also public normal_behavior
    //@     requires str != null; 
    //-RAC@     ensures \result.charArray != null; // FIXME - should be implict because of invariants?
    //@     ensures \result.length() == length() + str.length();
    //-RAC@ ensures \result.equals(concat(this,str));
    public /*@ pure @*/ /*@ non_null @*/ String concat(/*@ nullable */ String str);

    /*@  public normal_behavior
      @   //-RAC@ ensures ((Object)\result.charArray).__owner == \result;
      @   ensures \result.length() == length()
      @            && (\forall int i; 0 <= i && i < length();
      @                  \result.charAt(i) 
      @                     == ((charAt(i) == oldChar) ? newChar : charAt(i)));
      @*/
    public /*@ pure @*/ /*@ non_null @*/ String replace(char oldChar,
                                                        char newChar);

    /*@  public normal_behavior
      @    ensures \result != null;
      @  pure
      @*/
    public String replace(CharSequence oldString, CharSequence newString);

    /* FIXME +@ public normal_behavior
      @     requires regex != null;
      @     assignable \nothing;
      @     ensures \result <==> Pattern.matches(regex, this);
      @*/
    public /*@ pure @*/ boolean matches(/*@ non_null @*/ String regex);

    /* FIXME +@ public normal_behavior
      @     requires regex != null && replacement != null;
      @     assignable \nothing;
      @     ensures equals(\result,
      @               Pattern.compile(regex).matcher(this)
      @                      .replaceFirst(replacement));
      @*/
    public /*@ pure @*/ /*@ non_null @*/
        String replaceFirst(/*@ non_null @*/ String regex,
                            /*@ non_null @*/ String replacement);

    /* FIXME +@ public normal_behavior
      @     requires regex != null && replacement != null;
      @     assignable \nothing;
      @     ensures equals(\result,
      @               Pattern.compile(regex).matcher(this)
      @                      .replaceAll(replacement));
      @*/
    public /*@ pure @*/ /*@ non_null @*/
        String replaceAll(/*@ non_null @*/ String regex,
                          /*@ non_null @*/ String replacement);

    /*@ public normal_behavior
           ensures !\fresh(\result); // TODO presuming interned for ease of proof
        model public static pure helper heap_free non_null String split(String s, String regex, int position);
     */
        
    /*@ public normal_behavior
           ensures \result >= 1;
        model public static pure helper heap_free int numsplit(String s, String regex);
     */
        
    /*@ public normal_behavior
      @   ensures \fresh(\result);
      @   //  ensures equals(\result,
          //                  Pattern.compile(regex).split(this, limit));
      @   ensures (* output strings correspond to input substrings *);
      @   ensures limit > 0 ==> \result.length == limit;
      @*/
    //@ pure helper
    public String[] split(/*@ non_null @*/ String regex, int limit);

    /*@ public normal_behavior
      @   ensures \fresh(\result);
      @   ensures \result.length >= 1;
      @   ensures \result.length == numsplit(this,regex);
      @   ensures (\forall int i; 0 <= i < \result.length; \result[i] != null); // Including this avoids the needs for an instantiation, which is not always triggered
      @   ensures (\forall int i; 0 <= i < \result.length; \result[i] == split(this,regex,i));
      @*/
    //@ pure helper
    public String[] split(/*@ non_null @*/ String regex);

    /*@  public normal_behavior
      @   requires locale != null;
      @   ensures \fresh(\result) && \result.length() == length();
      @   ensures (* \result == a lower case conversion of this using the 
      @                          rules of the given locale *);
      @*/
    public /*@ pure @*/
        String toLowerCase(/*@ non_null @*/ Locale locale);

    /*@  public normal_behavior
      @   ensures \fresh(\result) && \result.length() == length();
      @   ensures \result != null
      @            && equals(\result,toLowerCase(Locale.getDefault()));
      @*/
    public /*@ pure @*/ String toLowerCase();

    /*@  public normal_behavior
      @   requires locale != null;
      @   ensures \fresh(\result) && \result.length() == length();
      @   ensures (* \result == an upper case conversion of this using the 
      @                          rules of the given locale *);
      @*/
    public /*@ pure @*/ /*@ non_null @*/
        String toUpperCase(/*@ non_null @*/ Locale locale);

    /*@  public normal_behavior
      @   ensures \fresh(\result) && \result.length() == length();
      @   ensures \result != null
      @            && equals(\result,toUpperCase(Locale.getDefault()));
      @*/
    public /*@ pure @*/ /*@ non_null @*/ String toUpperCase();

    /*@  public normal_behavior
      @   ensures \result != null
      @            && \result.length() <= length()
      @            && \result.charAt(0) > ' '
      @            && \result.charAt((int)(\result.length() - 1)) > ' ';
      @*/
    // FIXME - be more precise about what is omitted; also avoid recursion
    public /*@ pure @*/ /*@ non_null @*/ String trim();

    /*@ also
      @  public normal_behavior
      @    ensures \result != null && \result == this;
      @*/
    public /*@ pure @*/ /*@ non_null @*/ String toString();
    
    /*-RAC@  public normal_behavior
      @    assignable \nothing;
      @    ensures \result.length == length();
      @    ensures \fresh(\result);
      @    ensures CharSequence.equal(\result,charArray);
      @*/
    public /*@ pure @*/ char /*@ non_null @*/ [] toCharArray();

    /*@  public normal_behavior
      @    ensures \result != null;
      @    // FIXME ? \result is fresh?
      @  also public normal_behavior
      @    requires obj == null;
      @    ensures \result != null && equals(\result,"null");
      @  also public normal_behavior
      @    requires obj instanceof String;
      @    ensures \result.equals(obj);   // \result == obj ??? FIXME
      @  also public normal_behavior
      @    requires obj instanceof Character;
      @    ensures \result.length() == 1;
      @    ensures \result.charAt(0) == (char)(Character)obj;
      @*//*-RAC@  also public behavior
      @    requires obj != null;
      @    ensures obj.theString.charArray != null; // FIXME - should this be needed?
      @    ensures equals(\result,obj.theString); 
      @*/
    public static /*@ pure @*/ /*@ non_null @*/ String valueOf(/*@ nullable @*/Object obj);

    /*@ public normal_behavior
      @   requires data != null;
      @   ensures \result != null;
      @   //-RAC@ ensures CharSequence.equal(\result.charArray,data);
      @   //-RAC@ ensures \fresh(\result);
      @ also public exceptional_behavior
      @   requires data == null;
      @   signals_only NullPointerException;
      @*/
    public static /*@ pure @*/
        /*@ non_null @*/ String valueOf(char[] data);

    /*@ public normal_behavior
      @   requires data != null && offset >= 0 && count >= 0
      @       && offset + count < data.length;
      @   ensures \fresh(\result);
      @   ensures \result != null; 
      @   //-RAC@ ensures CharSequence.equal(\result.charArray,0,data,offset,count);
// FIXME - exceptions
      @*/
    public static /*@ pure @*/
        /*@ non_null @*/ String valueOf(char[] data,
                                        int offset, int count);

    /*@ public normal_behavior
      @   requires data != null;
      @   requires 0<=offset && 0<=count && offset+count <= data.length;
      @   ensures \result != null;
      @   ensures \fresh(\result);
      @   //-RAC@ ensures CharSequence.equal(\result.charArray,0,data,offset,count);
      @   //-RAC@ ensures \result.charArray.length == count;
      @   //-RAC@ ensures CharSequence.equal(\result.charArray,0,data,offset,count);
      @ also public exceptional_behavior
      @   requires data == null || offset < 0 || count < 0 ||
      @                            (offset+count)>data.length;
      @   signals_only NullPointerException, StringIndexOutOfBoundsException;
      @   signals (NullPointerException) data == null;
      @   signals (StringIndexOutOfBoundsException) offset<0 || count < 0
                                  || (offset+count)> data.length;
      @*/
    public static /*@ pure @*/
        /*@ non_null @*/ String copyValueOf(char[] data,
                                            int offset, int count);

    /*@ public normal_behavior
      @   requires data != null;
      @   ensures \result != null && equals(\result, String.valueOf(data));
      @   ensures \fresh(\result);
      @   //-RAC@ ensures \result.charArray.length == data.length;
      @   //-RAC@ ensures CharSequence.equal(\result.charArray,data);
      @ also public exceptional_behavior
      @   requires data == null;
      @   signals_only NullPointerException;
      @*/
    public static /*@ pure @*/
        /*@ non_null @*/ String copyValueOf(char[] data);
        
    /*@  public normal_behavior
      @   ensures \result == Boolean.toString(b);
      @*/
    public static /*@ pure @*/ /*@ non_null @*/ String valueOf(boolean b);

    /*@  public normal_behavior
      @   ensures \result != null;
      @   //-RAC@ ensures \result.charArray != null;
      @   ensures \result.length() == 1 && \result.charAt(0) == c;
      @*/
    public static /*@ pure @*/ /*@ non_null @*/ String valueOf(char c);

    /*@  public normal_behavior
      @   ensures \result == Integer.toString(i,10);
      @   //ensures String.equals(\result, Integer.toString(i,10)); // FIXME - feasibility probloem with gitbug467
      @   ensures \result.length() <= 11;
      @*/
    public static /*@ pure @*/ /*@ non_null @*/ String valueOf(int i);
    
    /*@  public normal_behavior
      @   ensures \result == Long.toString(l);
      @   ensures \result.length() <= 22;
      @*/
    public static /*@ pure helper non_null @*/ String valueOf(long l);
    
    /*@  public normal_behavior
      @   ensures \result == Float.toString(f);
      @   ensures \result.length() < 100; // FIXME - make this tighter
      @*/
    public static /*@ pure helper non_null @*/ String valueOf(float f);
    
    /*@  public normal_behavior
      @   ensures \result == Double.toString(d);
      @   ensures \result.length() < 100; // FIXME - make this tighter
      @*/
    public static /*@ pure helper non_null @*/ String valueOf(double d);
    
    /*-RAC@  public normal_behavior
      @   ensures isInterned(\result);
      @   ensures equals(\result,this);
      @   ensures isInterned(this) ==> (\result == this);
      @*/
    //@ pure
    public native /*@ non_null @*/ String intern();

    //@ public normal_behavior
    //@   ensures true; // No restriction on result
    //@ heap_free
    //@ public pure helper static model boolean isInterned(non_null String s);

    
    //@ public normal_behavior
    //@   requires true; // Ignoring bad formatting
    //@ pure
    public static String format(String format, Object ... args);

}
