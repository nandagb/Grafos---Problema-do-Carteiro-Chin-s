package java.text;
import java.util.*;

//@ non_null_by_default
public class SimpleDateFormat extends DateFormat {

      static final long serialVersionUID;
      static final int currentSerialVersion;
      private int serialVersionOnStream;
      private String pattern;
      private transient NumberFormat originalNumberFormat;
      private transient String originalNumberPattern;
      private transient char minusSign;
      private transient boolean hasFollowingMinusSign;
      private transient boolean forceStandaloneForm;
      private transient char[] compiledPattern;
      private static final int TAG_QUOTE_ASCII_CHAR;
      private static final int TAG_QUOTE_CHARS;
      private transient char zeroDigit;
      private DateFormatSymbols formatData;
      private Date defaultCenturyStart;
      private transient int defaultCenturyStartYear;
      private static final int MILLIS_PER_MINUTE;
      private static final String GMT;
      private static final java.util.concurrent.ConcurrentMap<Locale, NumberFormat> cachedNumberFormatData;
      private Locale locale;
      transient boolean useDateFormatSymbols;
      private static final int[] PATTERN_INDEX_TO_CALENDAR_FIELD;
      private static final int[] PATTERN_INDEX_TO_DATE_FORMAT_FIELD;
      private static final DateFormat.Field[] PATTERN_INDEX_TO_DATE_FORMAT_FIELD_ID;
      private static final int[] REST_OF_STYLES;
      //static final boolean $assertionsDisabled;
      public SimpleDateFormat();
      public SimpleDateFormat(String s);
      public SimpleDateFormat(String s, Locale locale);
      public SimpleDateFormat(String s, DateFormatSymbols symbols);
      private void initialize(Locale locale);
      private void initializeCalendar(Locale locale);
      private char[] compile(String s);
      private static void encode(int a, int b, StringBuilder s);
      private void initializeDefaultCentury();
      private void parseAmbiguousDatesAsAfter(Date date);
      public void set2DigitYearStart(Date date);
      public Date get2DigitYearStart();
      public StringBuffer format(Date date, StringBuffer sb, FieldPosition fp);
      private StringBuffer format(Date date, StringBuffer sb, Format.FieldDelegate fd);
      public AttributedCharacterIterator formatToCharacterIterator(Object o);
      private void subFormat(int a, int k, Format.FieldDelegate fd, StringBuffer sb, boolean b);
      private void zeroPaddingNumber(int a, int b, int c, StringBuffer sb);
      public Date parse(String s, ParsePosition pp);
      private int matchString(String s, int a, int b, String[] sa, CalendarBuilder cb);
      private int matchString(String s, int a, int b, Map<String, Integer> map, CalendarBuilder cb);
      private int matchZoneString(String s, int a, String[] sa);
      private boolean matchDSTString(String s, int a, int b, int c, String[][] saa);
      private int subParseZoneString(String s, int a, CalendarBuilder cb);
      private int subParseNumericZone(String s, int a, int b, int c, boolean bb, CalendarBuilder cb);
      private boolean isDigit(char c);
      private int subParse(String s, int a, int b, int c, boolean bb, boolean[] ba, ParsePosition pp, boolean bbb, CalendarBuilder cb);
      private boolean useDateFormatSymbols();
      private String translatePattern(String s, String ss, String sss);
      public String toPattern();
      public String toLocalizedPattern();
      public void applyPattern(String s);
      private void applyPatternImpl(String s);
      public void applyLocalizedPattern(String s);
      public DateFormatSymbols getDateFormatSymbols();
      public void setDateFormatSymbols(DateFormatSymbols symbols);
      public Object clone();
      public int hashCode();
      public boolean equals(Object o);
      private Map<String, Integer> getDisplayNamesMap(int i, Locale locale);
      private void readObject(java.io.ObjectInputStream stream) throws java.io.IOException, ClassNotFoundException;
      private void checkNegativeNumberExpression();
    
}
