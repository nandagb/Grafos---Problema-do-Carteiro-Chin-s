package java.util;

//@ non_null_by_default
public class Collections {
//  private static final int BINARYSEARCH_THRESHOLD;
//  private static final int REVERSE_THRESHOLD;
//  private static final int SHUFFLE_THRESHOLD;
//  private static final int FILL_THRESHOLD;
//  private static final int ROTATE_THRESHOLD;
//  private static final int COPY_THRESHOLD;
//  private static final int REPLACEALL_THRESHOLD;
//  private static final int INDEXOFSUBLIST_THRESHOLD;
//  private static java.util.Random r;
//  public static final java.util.Set EMPTY_SET;
//  public static final java.util.List EMPTY_LIST;
//  public static final java.util.Map EMPTY_MAP;
//  private java.util.Collections();
    
    //@ public normal_behavior  // FIXME - needs to say that all elements are still present and a permutation
    //@   ensures true;
    //@ pure
    public static <T extends Comparable<? super T>> void sort(List<T> list);

//  public static <T> void sort(java.util.List<T>, java.util.Comparator<? super T>);
//  public static <T> int binarySearch(java.util.List<? extends java.lang.Comparable<? super T>>, T);
//  private static <T> int indexedBinarySearch(java.util.List<? extends java.lang.Comparable<? super T>>, T);
//  private static <T> int iteratorBinarySearch(java.util.List<? extends java.lang.Comparable<? super T>>, T);
//  private static <T> T get(java.util.ListIterator<? extends T>, int);
//  public static <T> int binarySearch(java.util.List<? extends T>, T, java.util.Comparator<? super T>);
//  private static <T> int indexedBinarySearch(java.util.List<? extends T>, T, java.util.Comparator<? super T>);
//  private static <T> int iteratorBinarySearch(java.util.List<? extends T>, T, java.util.Comparator<? super T>);
//  public static void reverse(java.util.List<?>);
//  public static void shuffle(java.util.List<?>);
//  public static void shuffle(java.util.List<?>, java.util.Random);
//  public static void swap(java.util.List<?>, int, int);
//  private static void swap(java.lang.Object[], int, int);
//  public static <T> void fill(java.util.List<? super T>, T);
//  public static <T> void copy(java.util.List<? super T>, java.util.List<? extends T>);
//  public static <T extends java.lang.Comparable<? super T>> T min(java.util.Collection<? extends T>);
//  public static <T> T min(java.util.Collection<? extends T>, java.util.Comparator<? super T>);
//  public static <T extends java.lang.Comparable<? super T>> T max(java.util.Collection<? extends T>);
//  public static <T> T max(java.util.Collection<? extends T>, java.util.Comparator<? super T>);
//  public static void rotate(java.util.List<?>, int);
//  private static <T> void rotate1(java.util.List<T>, int);
//  private static void rotate2(java.util.List<?>, int);
//  public static <T> boolean replaceAll(java.util.List<T>, T, T);
//  public static int indexOfSubList(java.util.List<?>, java.util.List<?>);
//  public static int lastIndexOfSubList(java.util.List<?>, java.util.List<?>);
//  public static <T> java.util.Collection<T> unmodifiableCollection(java.util.Collection<? extends T>);
//  public static <T> java.util.Set<T> unmodifiableSet(java.util.Set<? extends T>);
//  public static <T> java.util.SortedSet<T> unmodifiableSortedSet(java.util.SortedSet<T>);
//  public static <T> java.util.NavigableSet<T> unmodifiableNavigableSet(java.util.NavigableSet<T>);

    //@ public normal_behavior
    //@   ensures (* \result.isImmutable *);
    //@   ensures \result.size() == list.size();
    //@   ensures (\forall int i; 0 <= i && i < \result.size(); \result.get(i) == list.get(i));
    //@ pure
    public static <T> java.util.List<T> unmodifiableList(java.util.List<? extends T> list);

    //@ public normal_behavior
    //@   ensures (* \result.isImmutable *);
    //@   ensures \result.size() == m.size();
    //@   ensures (\forall int i; 0 <= i && i < \result.size(); \result.get(i) == m.get(i));
    //@ pure
    public static <K, V> java.util.Map<K, V> unmodifiableMap(java.util.Map<? extends K, ? extends V> m);

    //  public static <K, V> java.util.SortedMap<K, V> unmodifiableSortedMap(java.util.SortedMap<K, ? extends V>);
//  public static <K, V> java.util.NavigableMap<K, V> unmodifiableNavigableMap(java.util.NavigableMap<K, ? extends V>);
//  public static <T> java.util.Collection<T> synchronizedCollection(java.util.Collection<T>);
//  static <T> java.util.Collection<T> synchronizedCollection(java.util.Collection<T>, java.lang.Object);
//  public static <T> java.util.Set<T> synchronizedSet(java.util.Set<T>);
//  static <T> java.util.Set<T> synchronizedSet(java.util.Set<T>, java.lang.Object);
//  public static <T> java.util.SortedSet<T> synchronizedSortedSet(java.util.SortedSet<T>);
//  public static <T> java.util.NavigableSet<T> synchronizedNavigableSet(java.util.NavigableSet<T>);
//  public static <T> java.util.List<T> synchronizedList(java.util.List<T>);
//  static <T> java.util.List<T> synchronizedList(java.util.List<T>, java.lang.Object);
//  public static <K, V> java.util.Map<K, V> synchronizedMap(java.util.Map<K, V>);
//  public static <K, V> java.util.SortedMap<K, V> synchronizedSortedMap(java.util.SortedMap<K, V>);
//  public static <K, V> java.util.NavigableMap<K, V> synchronizedNavigableMap(java.util.NavigableMap<K, V>);
//  public static <E> java.util.Collection<E> checkedCollection(java.util.Collection<E>, java.lang.Class<E>);
//  static <T> T[] zeroLengthArray(java.lang.Class<T>);
//  public static <E> java.util.Queue<E> checkedQueue(java.util.Queue<E>, java.lang.Class<E>);
//  public static <E> java.util.Set<E> checkedSet(java.util.Set<E>, java.lang.Class<E>);
//  public static <E> java.util.SortedSet<E> checkedSortedSet(java.util.SortedSet<E>, java.lang.Class<E>);
//  public static <E> java.util.NavigableSet<E> checkedNavigableSet(java.util.NavigableSet<E>, java.lang.Class<E>);
//  public static <E> java.util.List<E> checkedList(java.util.List<E>, java.lang.Class<E>);
//  public static <K, V> java.util.Map<K, V> checkedMap(java.util.Map<K, V>, java.lang.Class<K>, java.lang.Class<V>);
//  public static <K, V> java.util.SortedMap<K, V> checkedSortedMap(java.util.SortedMap<K, V>, java.lang.Class<K>, java.lang.Class<V>);
//  public static <K, V> java.util.NavigableMap<K, V> checkedNavigableMap(java.util.NavigableMap<K, V>, java.lang.Class<K>, java.lang.Class<V>);
//  public static <T> java.util.Iterator<T> emptyIterator();
//  public static <T> java.util.ListIterator<T> emptyListIterator();
//  public static <T> java.util.Enumeration<T> emptyEnumeration();
//  public static final <T> java.util.Set<T> emptySet();
//  public static <E> java.util.SortedSet<E> emptySortedSet();
//  public static <E> java.util.NavigableSet<E> emptyNavigableSet();

    //@ public normal_behavior
    //@   ensures (*\result.isImmutable *) && \result.isEmpty();
    //@ pure
    public static final <T> java.util.List<T> emptyList();

    //@ public normal_behavior
    //@   ensures (* \result.isImmutable *) && \result.isEmpty();
    //@ pure
    public static final <K, V> java.util.Map<K, V> emptyMap();
    
//  public static final <K, V> java.util.SortedMap<K, V> emptySortedMap();
//  public static final <K, V> java.util.NavigableMap<K, V> emptyNavigableMap();
//  public static <T> java.util.Set<T> singleton(T);
//  static <E> java.util.Iterator<E> singletonIterator(E);
//  static <T> java.util.Spliterator<T> singletonSpliterator(T);

    //@ public normal_behavior
    //@   ensures \fresh(\result);
    //@   ensures \result.values.length == 1;
    //@   ensures \result.values[0] == item;
    //@ pure
    public static <T> java.util.List<T> singletonList(T item);
    
    //@ public normal_behavior
    //@   ensures \result != null;  // TODO - content of map
    //@ pure
    public static <K, V> java.util.Map<K, V> singletonMap(K k, V v);
    
//  public static <T> java.util.List<T> nCopies(int, T);
//  public static <T> java.util.Comparator<T> reverseOrder();
//  public static <T> java.util.Comparator<T> reverseOrder(java.util.Comparator<T>);
//  public static <T> java.util.Enumeration<T> enumeration(java.util.Collection<T>);
//  public static <T> java.util.ArrayList<T> list(java.util.Enumeration<T>);
//  static boolean eq(java.lang.Object, java.lang.Object);
//  public static int frequency(java.util.Collection<?>, java.lang.Object);
//  public static boolean disjoint(java.util.Collection<?>, java.util.Collection<?>);
//  public static <T> boolean addAll(java.util.Collection<? super T>, T...);
//  public static <E> java.util.Set<E> newSetFromMap(java.util.Map<E, java.lang.Boolean>);
//  public static <T> java.util.Queue<T> asLifoQueue(java.util.Deque<T>);
    
}
