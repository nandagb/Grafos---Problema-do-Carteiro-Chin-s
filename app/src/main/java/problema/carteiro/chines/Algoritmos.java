/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package problema.carteiro.chines;


import java.util.ArrayList;
import java.util.List;

public class Algoritmos {
    /**
     * Função que checa se o grafo é conexo.
     * Complexidade: O(n^2) -> Executa o for até n*n-1 vezes
     * @param grafo Grafo para ser verificado
     * @param ver Vertice sendo verificado no momento
     * @param visitados Lista de vértices já visitados
     */
    public void checarGrafoConexo(Grafo grafo, Vertice ver, List<Vertice> visitados){
        // Para cada vértice adjascente do atual, se ele não foi visitado, visita e checa seus adjascentes
        for (Vertice v: grafo.getListaAdjacencia().get(ver)) {
            if (!visitados.contains(v))
            {
                visitados.add(v);
                checarGrafoConexo(grafo, v, visitados);
            }
        }
    }

    /**
     * Função que checa se o grafo é Euleriano.
     * Para isto se utiliza do teorema 2.1 do livro Teoria Computacional de Grafos do autor Jayme Luiz Szwarcfiter.
     * Complexidade: O(n^3) -> checagem do grafo conexo e checagem do grau par executa n vezes
     * @param grafo grafo para ser verificado
     * @return true caso seja Euleriano, false CC
     */
    public boolean checarGrafoEuleriano(Grafo grafo){
        boolean conexo = false;
        boolean euleriano = false;
        boolean grauPar = true;

        List<Vertice> visitados = new ArrayList<>();

        // Verificar se é conexo
        Vertice ver = grafo.getListaAdjacencia().keySet().stream().findFirst().get();
        visitados.add(ver);
        checarGrafoConexo(grafo, ver, visitados);
        // Se todos vertices foram visitados, o grafo é conexo
        if (visitados.size() == grafo.getV())
            conexo = true;

        System.out.println("Conexo: " + conexo);

        // Se conexo, verificar se todo nó tem grau par
        if (conexo){
            for (Vertice v: grafo.getListaAdjacencia().keySet()) {
                if (grafo.getListaAdjacencia().get(v).size() % 2 != 0)
                {
                    grauPar = false;
                }
            }
        }
        System.out.println("Grau Par: " + grauPar);

        // Se for conexo e todo nor for par, é euleriano
        if (conexo && grauPar)
            euleriano = true;

        System.out.println("Euleriano: " + euleriano);

        return euleriano;
    }

    /**
     * Algoritmo de Hierholzer.
     * Implementado assim como descrito no relatório.
     * Complexidade: O(m) -> número máximo de arestas que ele pode percorrer
     * @param grafo Grafo que gerará a trilha euleriana
     * @param ver Vértice atual sendo adicionado à trilha
     * @param trilhaEuleriana Lista que possui a trilha
     */
    public void hierholzer(Grafo grafo, Vertice ver, List<Vertice> trilhaEuleriana){
        for (int i = 0; i < grafo.getListaAdjacencia().get(ver).size(); i++)
        {
            Vertice v = grafo.getListaAdjacencia().get(ver).get(i);
            grafo.remAresta(ver.n, v.n);
            hierholzer(grafo, v, trilhaEuleriana);
        }
        trilhaEuleriana.add(ver);
    }

    public boolean algoritmoLinks(Grafo grafo) {
        boolean linkado = false;
        boolean euleriano = false;
        grafo.printGrafo();
        euleriano = checarGrafoEuleriano(grafo);

        if (euleriano){
            List<Vertice> trilhaEuleriana = new ArrayList<>();
            Vertice ver = grafo.getListaAdjacencia().keySet().stream().findFirst().get();
            hierholzer(grafo, ver, trilhaEuleriana);

            System.out.print("Trilha euleriana: ");
            for (Vertice v : trilhaEuleriana){
                System.out.print(v.n + " ");
            }

            linkado = true;

            return linkado;
        }

        return euleriano;
    }
}
